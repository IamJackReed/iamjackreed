---
title:  "Software Development"
subtitle: "It's not just about building software"
author: "'Jack Reed'"
avatar: "img/authors.png"
image: "img/d.jpg"
date:   2017-08-14 12:12:12
---
Software development, is not just about developing software, or at least it shouldn't be. Software development tends to have a lot of focus on output, and when I say the word ‘output’, I'm talking about 'velocity' (the amount of work getting done over time), deliverables, requirements etc. All of the outputs from development. And you may hear things like delivering shippable software fast is good, and that having a consistent velocity is great. But be careful, you don't want to start thinking that the sole aim is to just get requirements from the end user, so that the quicker you can design, build, test and ship those requirements. Unfortunately, there is (or at least there should be) a little more to it than that. It's the feedback that is useful, not just collecting requirements for the sake of it. Successful software is ultimately determined not by outputs, or how quickly requirements can be delivered, but by the actual outcomes and impact the software has after it has been delivered.

#### It All Starts With People and Ideas
When It comes to building software products or services it all starts with people and ideas, ideas about how people are going to use the product or service to get some form of benefit. There are many cases where the customer comes first, but when it comes to ideas about product functionality, I'm afraid the 'customer' isn't always right. In fact, their ideas are often bad ones. Here's an Example: Let's say there is a software product (system) that is being used by a company to help them take stock of their inventory. Each time a new stock item arrives the employees type the stocks details into the system. The employees of the company start to complain to management that when they are making data entries into the system, it's laborious and annoying for them because the system is old and slow. When asking the employees or even management for suggestions on possible solutions for this problem, their ideas are often just based on having a better version of that current product, which might not necessarily be the best viable solution. If a company is using software as a tool, then overtime it can play a big part in influencing or shaping the way in which they work. Resulting in them getting stuck into thinking that the way in which they work, has to match that of the existing technology and capabilities of the product that they're already using. In this example the problem is being framed as 'the system is old and slow', therefore the suggested solution might be to 'update the system to make it faster'. However, by reframing the problem to 'when updating the system with new inventory data, it's laborious and annoying' then it generates alternative solutions, like 'make new data entries automated'. This may explain why (not always), but it is often the software developers that come up with the best viable solutions, since they are aware of the technical possibilities.

#### Sorting The Good Ideas From The Bad Ones
It is not just customers or end users that have ideas about desired product functionality, ideas can come from stakeholders, developers, testers, business analysts, shareholders, etc. the list goes on. How to establish what should be built, this task often falls on the shoulders of the product owner, it is their responsibility to have a vision of what it is to be build, and convey that vision to the team building it. More importantly they need to sort the good ideas, from the bad ideas. This is done by them finding a sweet spot that sits in the middle between what is 'Valuable', 'Usable', and 'Feasible'. For example it isn't much use having a great idea for an amazing solution, if it's too expensive, or a solution that solves the problem, but is too complex for anyone to use. Therefore, messing this ratio up to get too much of one, and not enough of the other, then there is high chance of failure. This is why it pays to to keep a regular, short feedback loop from the customers and end users, so that the solutions (or part of them) that are being built can be validated. Remember it's only really after seeing the outcomes that you'll understand the actual value.

#### That's Not What We Were Expecting
In software development it is often expected (certainly by the teams building them) that the features or ideas about product functionality can frequently change. Which might explain why _'Accommodate changing requirements throughout the development process'_ is one of the twelve Agile Manifesto Principles. That being said, there are cases where we would deliberately want to introduce uncertainty into estimating on features that we're not 100% sure of. And the reason for this is, that we simply need validation on the parts that we have done so far before going any further. But it can be a common mistake to fall into thinking that because there is a high chance of change, then there is isn't much point in listing all the requirements for a feature. As a result, this can produce a less than desirable outcome, a low quality version of what was expected, and introduce potential rework. When writing the acceptance criteria for a feature, I'd suggest to always base them on all of the information that you have at that time, and ensure that the expectancy levels are always clear, to the team, to stakeholders and to the customers.

#### Conclusion
To help avoid a lot of these types of problems and build better software, then the time should be spent focusing on solving or providing the right solution. It's not just a case of delivering requirements fast or even failing fast, it should be more about learning fast. Try and better understand the end users behaviours and patterns of working. When it comes to defining the requirements, if there is ambiguity when writing an acceptance criteria for a feature, then perhaps a better understanding of that feature is needed. The acceptance criteria for a feature should be based on the information that you have at that time, but make sure those expectancy levels are always clear. Another way to help get better solutions is to get the team using user stories as a way to describe product functionality, user stories are by far the most popular method used within software development to describe desired functionality, and a great way to understand the who, what and why. They help with being able to stay in the mindsets of the end users, but how 'user stories' are used can be easily misunderstood. The real benefit of using them comes from how they are created by using conversations, rather than how they are actually written. For more reading on 'User Stories & User Story Mapping', check out ['_User Stories and User Story Examples_'](https://www.mountaingoatsoftware.com/agile/user-stories) by _Mike Cohn_, and even though Mike and Jeff may not see eye to eye, another good recommendation would be ['_User Story Mapping_'](http://jpattonassociates.com/user-story-mapping/) by _Jeff Patton_.
